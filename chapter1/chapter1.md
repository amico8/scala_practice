# 第1章 スケーラブルな言語
* [1.1 プログラマーとともに成長する言語](#1.1)
* [1.2 Scalaがスケーラブルな理由](#1.2)
* [1.3 Scalaを選ぶ理由](#1.3)
* [1.4 Scalaのさまざまなルーツ](#1.4)
* [まとめ](#matome)

---

<a name="1.1"></a>
## 1.1 プログラマーとともに成長する言語

``` scala
// サンプルプログラム
var capital = Map("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
```

* 高水準であり的確であり、セミコロンや型名による修飾でごちゃごちゃされてない。  
Perl、Python、Rubyなどの新しい「スクリプト」言語のようである。  
これらの言語はどれも言語自体の構文として「連想マップ」をサポートしている。  
* Scalaは書きやすさと柔軟さを両立させる。  
* 伽藍とバザール  
「伽藍」・・・建設に時間のかかるほぼ完璧な建造物。  
「バザール」・・・そこで働く人々によって日々修正・拡張される。  
Scalaは、プログラマが修正・拡張できるように設計されているという意味ではるかにバザール的である。  
* Scala.BigInt・・・扱える数の上限をいくらでも大きくできる整数の型。  
* プログラミング言語「Erlang」で使われている「アクター」アプローチ  
アクター（Actor）・・・スレッドの上に実装できる並行実行のモデル。  


<a name="1.2"></a>
## 1.2 Scalaがスケーラブルな理由
* Scalaがスケーラビリティを実現している決め手は、オブジェクト指向と関数型プログラミングの結合  
（スケーラビリティ・・・拡張性。システムの利用者や負荷の増大に応じて、柔軟に性能や機能を向上させられること。）
* Scalaは純粋なオブジェクト指向言語である。すべての値はオブジェクトであり、すべての操作はメソッド呼び出しである。  
（トレイト・ミックスイン合成）  
* Scalaは本格的な関数型言語である。関数型プログラミングは、主として2つの発想によって導かれている。  
    * 関数を一人前の値として扱うこと。関数型言語では、関数は整数や文字列などと同格の値である。  
        * 関数は、他の関数に引数として渡したり、他の関数から処理結果として返したり、変数に格納したりすることができる。  
        * 関数の中で整数値を定義できるのと同じように、関数の中で別の関数を定義することもできる。  
        * 名前をつけずに関数を定義することができる。
    * プログラム内の操作は、データをその場で書き換え（変更）するのではなく、入力の値を出力の値にマップ（写像）すべきだ。  
        * Scalaはイミュータブル（変更不可能）なリスト、マップ、集合（セット）を持っている。  
        * メソッドはどんな副作用も持ってはならない。


<a name="1.3"></a>
## 1.3 Scalaを選ぶ理由
### 互換性（Javaとの共存）
* Scalaコードは、Javaメソッドを呼び出し、Javaフィールドにアクセスし、Javaクラスを継承し、Javaインターフェースを実装できる。  
* Scalaの文字列は、文字列を整数や浮動小数点数に変換するtoInt、toFloatメソッドをサポートする。  
（Integer.parseInt(str)ではなく、str.toIntと書くことができる）  
* Scalaでは、通常なら一致しない場合や存在しないメンバーが選択された場合に必ず適用される暗黙の型変換を定義できる。  
* Scalaの高度な機能は、何らかの方法でエンコードしてからでなければJavaにマッピングできない。  

### 簡潔性（Javaの半分以下のコード量）

```java
// Java
class MyClass {
  private int index;
  private String name;
  public MyClass(int index, String name) {
    this.index = index;
    this.name = name;
  }
}
```

```scala
// Scala
class MyClass(index: Int, name: String)
```

### 高水準（抽出度の高いコード、新しい制御構造を定義できる表現力）
nameというString変数があり、このString変数に大文字が含まれているかどうかを判定するコード  

```java
// Java
boolean nameHasUpperCase = false;
for (int i = 0; name.length(); ++i) {
  if (Character.isUpperCase(name.charAt(i))) {
    nameHasUpperCase = true;
    break;
  }
}
```

* Javaコードは、ループで1文字ずつ処理する低水準の存在として文字列を扱っている。  

```scala
// Scala
val nameHasUpperCase = name.exists(_.isUpper)
```

* Scalaコードは、述語関数（結果がBoolean関数となる関数リテラル）でテストできるより高い水準の存在として文字列を扱っている。  

### 静的な型付け（簡潔性、柔軟性、検証可能性、安全性、ドキュメント性）
* 静的型付け・・・プログラミング言語で書かれたプログラムにおいて、変数やサブルーチンの引数や返り値などの値について、その型がプログラム実行よりも前に予め決められている（コンパイル時などに）という型システムの性質。  
* 動的型付け・・・プログラムを実行しながら型検査を行う。
* Scalaは、ジェネリックな構文要素で型をパラメータ化したり、論理積を使って型を結合したり、抽象型で型の小さいを隠蔽したりすることができる。  
* 検証可能な性質
* 安全なリファクタリング
* ドキュメント性


<a name="1.4"></a>
## 1.4 Scalaのさまざまなルーツ
特になし


<a name="matome"></a>
## まとめ
* 関数型というものをそもそもちゃんと理解できてない・・・orz
* Actorがよくわからん
* トレイトってどうやって使うんだ・・・？ミックスイン合成って？？  
* Scalaが色々な言語の影響を受けているということはわかった
