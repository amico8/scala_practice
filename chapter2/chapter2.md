# 第2章 Scalaプログラミングの第一歩
* [2.1 [ステップ1] Scalaインタープリターの使い方を学ぶ](#2.1)
* [2.2 [ステップ2] 変数を定義する](#2.2)
* [2.3 [ステップ3] 関数を定義する](#2.3)
* [2.4 [ステップ4] 簡単なScalaスクリプトを書く](#2.4)
* [2.5 [ステップ5] whileによるループ、ifによる分岐](#2.5)
* [2.6 [ステップ6] foreachとforによる反復実行](#2.6)
* [まとめ](#matome)

---

<a name="2.1"></a>
## 2.1 [ステップ1] Scalaインタープリターの使い方を学ぶ
* Scalaコンパイラーは、ScalaコードをJavaバイトコードにコンパイルする時に可能な限りJavaプリミティブ型を使う。  
（プリミティブ型のパフォーマンス上のメリットを享受できるようにするため）


<a name="2.2"></a>
## 2.2 [ステップ2] 変数を定義する
* val：初期化後に別の値を代入することはできない  
* var：変数が有効であれば、何度でも代入し直すことができる  

```scala
// 型を定義していなくても型推論でmsgの型をStringだと推測している
val msg = "Hello, world!"
```

```scala
// 明示的に型を指定する場合
val msg2: java.lang.String = "Hello again, world!"
// 単純名でも良い
val msg3: String = "Hello yet again, world!"
```


<a name="2.3"></a>
## 2.3 [ステップ3] 関数を定義する
### 関数定義の基本形

```scala
def 関数名(引数: 型, 引数: 型) : 結果型 = {
  関数の処理
}
```

```scala
def max(x: Int, y: Int): Int = {
  if (x > y)
    x
  else
    y
}
```

* 関数定義の先頭には「def」と書く。  
* 関数のパラメータ型については、型推論を行わないので、すべての関数パラメータにコロンを挟んで型アノテーションを付ける必要がある。  
* Javaではメソッドが返す値のことを戻り型と呼ぶが、Scalaでは同じものを結果型と呼ぶ。  
* 関数が再帰的（自分自身を呼び出すもの）な場合には、関数の結果型を明示的に指定しなければならない。  
でもコンパイラが要求しなくても、結果型は明示的に示した方が良い場合が多い。

```scala
// 上記の関数は次のようにも書ける
def max2(x: Int, y:Int) = if (x < y) x else y
```

```scala
// パラメータをとらず、意味のある結果も返さない関数の定義。結果型は「Unit」になる。
// 結果型がUnitのメソッドは、副作用のためにのみ実行される。
def greet() = println("Hello, world!")
```


<a name="2.4"></a>
## 2.4 [ステップ4] 	簡単なScalaスクリプトを書く
* Scalaスクリプトに渡すコマンド行引数には、argsという名前のScala配列を介してアクセスできる。  

```scala
// ×
args[0]  
// ◯
args(0)
```
* スクリプトファイル内のプログラムやコメントに日本語を利用する場合、文字コードはUTF-8にする必要がある。


<a name="2.5"></a>
## 2.5 [ステップ5] whileによるループ、ifによる分岐
* Scalaでは、Javaのような「++i」「i++」は使えない。インクリメントするには「i += 1」と書く必要がある。


<a name="2.6"></a>
## 2.6 [ステップ6] foreachとforによる反復実行

```scala
// ちなみにこれはScalaが推奨しない書き方。varがよろしくないのかな
var i = 0
while (i < args.length) {
  println(args(i))
}
```

```scala
// 上記のループ文は次のように書ける
args.foreach((arg: String) => println(arg))

// 更に簡潔に
args.foreach(arg => println(arg))
// 更に更に
args.foreach(println)
```

* このコードは、argsのforeachメソッドを呼び出し、そのメソッドに関数を渡している。  
渡されているのはargという名前の1個のパラメータをとる関数リテラル（名前の無い関数）で、関数本体はprintln(arg)である。  
* 関数リテラルが1個の引数を取る1文から構成される場合は、引数を明示的に指定しなくてすむ。

* ちなみにforループでは以下のように書く。  

```scala
for (arg <- args)
  println(arg)
```

### Scalaの関数リテラルの構文

```scala
(引数: 型, 引数: 型) => 関数本体
```

```scala
(x: Int, y: Int) => x + y
```


<a name="matome"></a>
## まとめ
* 関数定義の基本形で、型と引数が逆なのと、結果型が後ろに来るのが戸惑う。。  
でもこの形式は型推論を要求しやすくするためらしい。  
* 関数リテラルのメリット・・・命名する必要の無い関数をシンプルに記述できる。既存の関数/変数名との衝突を回避できる。
