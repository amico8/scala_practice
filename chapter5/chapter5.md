# 第5章 基本型と演算子
* [5.1 基本型](#5.1)
* [5.2 リテラル](#5.2)
* [5.3 演算子はメソッドである](#5.3)
* [5.4 算術演算](#5.4)
* [5.5 関係演算子と論理演算子](#5.5)
* [5.6 ビット単位演算](#5.6)
* [5.7 オブジェクトの等価性](#5.7)
* [5.8 演算子の優先順位と結合性](#5.8)
* [5.9 リッチラッパー](#5.9)
* [まとめ](#matome)

---

<a name="5.1"></a>
## 5.1 基本型
* 特になし


<a name="5.2"></a>
## 5.2 リテラル
### 文字リテラル
```scala
// 生の文字列を出力するには「"""」をつける
println("""Welcome toUltamix 3000.
           Type "HELP" for help.""")

// スペースを含ませずに出力するには「|」を入れてstripMarginメソッドを呼び出す
println("""|Welcome toUltamix 3000.
           |Type "HELP" for help.""".stripMargin)

```

### シンボルリテラル
* シンボルリテラルの書き方・・・「’hoge」のように、先頭に「’」をつける
* 「’hoge」というリテラルは、コンパイラによってファクトリーメソッド呼び出しの「Symbol("hoge")」に展開される
* Stringは同じ内容でも異なるインスタンスが存在しうる（"abc" と new String("abc") は、インスタンスが異なる）のに対し、  
Symbolでは同じ内容ならインスタンスも等しい

```scala
scala > "abc" eq new String("abc")
res1: Boolean = false

scala > 'abc eq Symbol("abc")
res2: Boolean = true
```

* シンボルリテラルは、シンボルの実体が1つしか作られない  
* 同じシンボルリテラルを2度書いた時、両方の式は全く同一のSymbolオブジェクトを参照する
* なので、SymbolはMapのキーに使うのに向いているらしい

* シンボルは「.name」でそのシンボルの名前を見出すことができる
```Scala
scala>  val s = 'SampleSymbol 
s: Symbol = 'SampleSymbol

scala> s.name
res18: String = SampleSymbol
```

<a name="5.3"></a>
## 5.3 演算子はメソッドである
* 前置（prefix）
    * -7 のように、メソッドを持つオブジェクトの前にメソッド名を書く  
    * -7 は、正式には```(7).unary_-``` と表現される
    * 前置演算子として使える識別子は、「+」「-」「!」「~」だけである
* 中置（infix）
    * 7 + 2 のように、オブジェクトと引数の間にメソッド名を書く
* 後置（postfix）
    * 7 toLong のように、オブジェクトの後にメソッド名を書く
    * 後置演算子は、ドットや括弧をつけずに呼び出される引数なしのメソッド
    （メソッドの空()やメソッド前の.は省略可能）
```scala
// 後置演算子として使用
scala > val s = "hoge"
scala > s toLowerCase
res84: java.lang.String = hoge

// 実際はこう処理されている
scala > s.toLowerCase()

// .を省略
scala > s toLowerCase()
// 空()を省略
scala > s.toLowerCase  
```


<a name="5.4"></a>
## 5.4 算術演算
* 特になし


<a name="5.5"></a>
## 5.5 関係演算子と論理演算子
* 論理AND式の左辺がfalseと評価される場合、式の結果は間違いなくfalseなので右辺は評価されない（ショートサーキット）


<a name="5.6"></a>
## 5.6 ビット単位演算
* 特になし


<a name="5.7"></a>
## 5.7 オブジェクトの等価性
* 2つのオブジェクトが等しいかどうかを比較したいときは、「==」か「!=」を使う  
（nullとの比較もできる）
* 左辺がnullかどうかチェックし、nullでなければequalsメソッドを呼び出す


<a name="5.8"></a>
## 5.8 演算子の優先順位と結合性
* 特になし


<a name="5.9"></a>
## 5.9 リッチラッパー
* Scalaの基本形で使えるメソッドは、演算子以外にもある
```scala
// 大きい方を取得（結果は5）
0 max 5

// 小さい方を取得（結果は0）
0 min 5

// 絶対値を取得（結果は2.7）
-2.7 abs
```


<a name="matome"></a>
## まとめ
* Scalaの演算子がメソッド呼び出しだということ
* Scalaの基本型は、リッチラッパーへの暗黙の型変換を通じて役立つメソッドを増やしているということ
* このへんはJavaとほぼ同じだから理解できる・・・

